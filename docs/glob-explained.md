# `.glob()` 이란? — 12살도 이해하는 설명

이 문서는 `src/rag/parser.py` 165번째 줄에 나오는 다음 코드를 설명합니다.

```python
pdf_files = list(PDF_DIR.glob("*.pdf"))
```

---

## 1. 먼저 알아야 할 것: `PDF_DIR`은 뭔가요?

- `PDF_DIR`은 **폴더 경로**입니다.
- 이 프로젝트에서는 `data/pdfs` 라는 폴더를 가리킵니다.
- "여기 안에 있는 파일들을 다룰 거야"라고 정해 둔 **기준 폴더**라고 생각하면 됩니다.

---

## 2. `.glob()` 은 뭔가요? (쉬운 비유)

**방 안에서 "이름이 ~로 끝나는 물건"만 골라 오는 것**과 비슷합니다.

- 방 = `PDF_DIR` (즉, `data/pdfs` 폴더)
- "~로 끝나는" 조건 = `"*.pdf"` 라는 **패턴(pattern)**

즉, **"이 폴더 안에서, 이름이 `.pdf`로 끝나는 파일만 찾아줘"**라고 시키는 게 `.glob("*.pdf")` 입니다.

- `*` = "아무 글자나 여러 개 와도 돼" (와일드카드)
- `.pdf` = "마지막은 반드시 .pdf 여야 해"

그래서:

- `report.pdf` → ✅ 찾음
- `논문.pdf` → ✅ 찾음
- `document.PDF` → 대소문자에 따라 다를 수 있음 (보통 `.pdf`만 찾음)
- `report.pdf.bak` → ❌ (.pdf로 끝나지 않음)
- `readme.txt` → ❌ (pdf가 아님)

---

## 3. `.glob()` 이 **동작**하는 순서 (단계별)

1. **시작**: `PDF_DIR`이 가리키는 폴더(`data/pdfs`)로 간다.
2. **검사**: 그 폴더 **안에 있는 모든 파일·폴더 이름**을 하나씩 본다.
3. **매칭**: 이름이 `*.pdf` 패턴과 맞는지 확인한다.  
   (끝이 `.pdf`인지 보는 것)
4. **수집**: 맞는 것만 골라서 **순서대로** 담는다.
5. **반환**: 그걸 **반복 가능한 객체(iterator)** 로 돌려준다.  
   (한 번에 전부 메모리에 올리지 않고, 필요할 때마다 하나씩 줄 수 있는 형태)

정리하면:  
**"data/pdfs 폴더를 열고, 이름이 .pdf로 끝나는 것만 찾아서, 나중에 하나씩 꺼낼 수 있게 담아둔 통"**을 만드는 단계라고 보면 됩니다.

---

## 4. `list(...)` 는 왜 붙이나요?

- `.glob()` 이 주는 건 위에서 말한 **"나중에 하나씩 꺼낼 수 있는 통"** 형태입니다.
- `list(...)` 는 **"그 통에 있는 걸 전부 꺼내서, 번호가 붙은 리스트로 만들어줘"**라는 뜻입니다.

그래서:

- **`.glob("*.pdf")`만 쓰면**: 필요할 때마다 하나씩 꺼내 쓸 수 있는 형태.
- **`list(PDF_DIR.glob("*.pdf"))`** 하면:  
  "지금 당장 전부 모아서, 0번, 1번, 2번 … 이렇게 접근할 수 있는 **리스트**로 만들어줘"가 됩니다.

우리 코드에서는 **몇 개인지 확인하고**, **첫 번째 PDF를 골라 쓰는** 등 리스트처럼 쓰고 싶어서 `list()`로 한 번 감싼 것입니다.

---

## 5. `pdf_files` 에 **실제로** 뭐가 들어가나요?

- **타입**: **리스트 (list)**
- **안에 들어가는 것**: **각 PDF 파일의 경로** (`pathlib.Path` 객체)

예를 들어 `data/pdfs` 안에  
`report.pdf`, `논문.pdf`, `summary.pdf`  
세 개가 있다면:

```text
pdf_files = [
    Path("data/pdfs/report.pdf"),   # 0번
    Path("data/pdfs/논문.pdf"),     # 1번
    Path("data/pdfs/summary.pdf"),  # 2번
]
```

- `len(pdf_files)` → `3`
- `pdf_files[0]` → 첫 번째 PDF 경로
- `pdf_files[1]` → 두 번째 PDF 경로  
… 이런 식으로 **"PDF 파일 경로들이 번호 순서대로 들어 있는 리스트"**가 됩니다.

---

## 6. `.glob()` 은 문자열(str)에서 쓰나요?

**아니요.** `.glob()`은 **문자열이 아니라 `pathlib.Path` 객체**에 있는 메서드입니다.  
호출하는 쪽은 `Path`, 인자로 넣는 패턴만 문자열(str)입니다.

```python
# ❌ str에는 .glob()이 없음 → AttributeError
folder = "data/pdfs"
folder.glob("*.pdf")

# ✅ Path로 바꾼 뒤 사용
from pathlib import Path
folder = Path("data/pdfs")
list(folder.glob("*.pdf"))
```

| 구분 | 타입 |
|------|------|
| `.glob()`을 **호출하는 대상** | `Path` |
| `.glob()`에 **넣는 패턴** | `str` (예: `"*.pdf"`) |

---

## 7. 이걸 한 문장으로 정리하면?

> **`pdf_files = list(PDF_DIR.glob("*.pdf"))`**  
> = "`data/pdfs` 폴더 안에서 이름이 `.pdf`로 끝나는 파일을 **전부 찾아서**, 그 **경로들**을 **리스트**로 만들어 `pdf_files` 변수에 넣는다."

---

## 8. 왜 이렇게 쓰나요? (이 코드의 목적)

- 나중에 `if not pdf_files:` 로 "PDF가 하나도 없으면"을 체크하고
- `pdf_path = pdf_files[0]` 으로 **첫 번째 PDF**를 골라서 파싱하는 데 쓰기 위해서입니다.

즉, **"그 폴더에 있는 PDF 목록을 한 번에 모아 두고, 그중 하나(또는 여러 개)를 골라 쓰기 위해"** `.glob()` 과 `list()` 를 사용한 것입니다.

---

## 9. 참고: `*` 말고 다른 패턴도 쓸 수 있나요?

`.glob()` 에는 이런 식으로 패턴을 줄 수 있습니다.

| 패턴      | 의미 (쉽게) |
|-----------|--------------|
| `*.pdf`   | 끝이 `.pdf` 인 모든 파일 |
| `report*` | 이름이 `report`로 시작하는 모든 파일 |
| `*2024*`  | 이름 안에 `2024`가 들어간 모든 파일 |
| `*.txt`   | 끝이 `.txt` 인 모든 파일 |

`*` 는 "여기에 뭐가 와도 돼" 라는 뜻의 **와일드카드**라고 부릅니다.

---

이해가 잘 되는지, 다음을 스스로 생각해 보면 좋습니다.

- "만약 `data/pdfs` 에 PDF가 하나도 없으면 `pdf_files` 는 어떻게 될까?"  
  → 빈 리스트 `[]` 가 됩니다.
- "`pdf_files[0]` 은 무엇을 가리키나?"  
  → 리스트의 첫 번째 PDF 파일의 **경로(Path)** 입니다.
